diff -ruN a/arch/arm/boot/dts/imx6ull-14x14-lumi.dts b/arch/arm/boot/dts/imx6ull-14x14-lumi.dts
--- a/arch/arm/boot/dts/imx6ull-14x14-lumi.dts	1970-01-01 03:00:00.000000000 +0300
+++ b/arch/arm/boot/dts/imx6ull-14x14-lumi.dts	2020-10-02 21:51:28.000000000 +0300
@@ -0,0 +1,260 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+//
+// Copyright (C) 2016 Freescale Semiconductor, Inc.
+
+/dts-v1/;
+
+#include "imx6ull.dtsi"
+#include "imx6ul-14x14-evk.dtsi"
+
+/ {
+	model = "Xiaomi Gateway";
+	compatible = "xiaomi,gateway-lumi", "fsl,imx6ull-14x14-evk", "fsl,imx6ull";
+
+	usdhc1_pwrseq: usdhc1_pwrseq {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_wifi>;
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpio5 1 GPIO_ACTIVE_LOW>;
+	};
+
+	backlight_display: backlight-display {
+		status = "disabled";
+	};
+
+	lumi_g {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0x00 5000000>;
+	    brightness-levels = <0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1a 0x1b 0x1c 0x1d 0x1e 0x1f 0x20 0x21 0x22 0x23 0x24 0x25 0x26 0x27 0x28 0x29 0x2a 0x17 0x2c 0x2d 0x2e 0x2f 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x3a 0x3b 0x3c 0x3d 0x3e 0x3f 0x40 0x41 0x42 0x43 0x44 0x45 0x46 0x47 0x48 0x49 0x4a 0x4b 0x4c 0x4d 0x4e 0x4f 0x50 0x51 0x52 0x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5a 0x5b 0x5c 0x5d 0x5e 0x5f 0x60 0x61 0x62 0x63 0x64>;
+		default-brightness-level = <0x00>;
+		status = "okay";
+	};
+
+	lumi_r {
+		compatible = "pwm-backlight";
+		pwms = <&pwm2 0x00 5000000>;
+	    brightness-levels = <0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1a 0x1b 0x1c 0x1d 0x1e 0x1f 0x20 0x21 0x22 0x23 0x24 0x25 0x26 0x27 0x28 0x29 0x2a 0x17 0x2c 0x2d 0x2e 0x2f 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x3a 0x3b 0x3c 0x3d 0x3e 0x3f 0x40 0x41 0x42 0x43 0x44 0x45 0x46 0x47 0x48 0x49 0x4a 0x4b 0x4c 0x4d 0x4e 0x4f 0x50 0x51 0x52 0x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5a 0x5b 0x5c 0x5d 0x5e 0x5f 0x60 0x61 0x62 0x63 0x64>;
+		default-brightness-level = <0x00>;
+		status = "okay";
+	};
+
+	lumi_b {
+		compatible = "pwm-backlight";
+		pwms = <&pwm3 0x00 5000000>;
+	    brightness-levels = <0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1a 0x1b 0x1c 0x1d 0x1e 0x1f 0x20 0x21 0x22 0x23 0x24 0x25 0x26 0x27 0x28 0x29 0x2a 0x17 0x2c 0x2d 0x2e 0x2f 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x3a 0x3b 0x3c 0x3d 0x3e 0x3f 0x40 0x41 0x42 0x43 0x44 0x45 0x46 0x47 0x48 0x49 0x4a 0x4b 0x4c 0x4d 0x4e 0x4f 0x50 0x51 0x52 0x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5a 0x5b 0x5c 0x5d 0x5e 0x5f 0x60 0x61 0x62 0x63 0x64>;
+		default-brightness-level = <0x00>;
+		status = "okay";
+	};
+	tfa9882: tfa9882 {
+		#sound-dai-cells = <0>;
+		compatible = "fsl,tfa9882";
+		clocks = <&clks IMX6UL_CLK_SAI1>;
+		clock-names = "mclk";
+	};
+	sound-tfa9882 {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "tfa9882-audio";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,frame-master = <&cpudai>;
+		simple-audio-card,bitclock-master = <&cpudai>;
+		simple-audio-card,widgets =
+			"Line", "Left Line Out Jack",
+			"Line", "Right Line Out Jack";
+		simple-audio-card,routing =
+			"Left Line Out Jack", "LINEVOUTL",
+			"Right Line Out Jack", "LINEVOUTR";
+
+		cpudai: simple-audio-card,cpu {
+			sound-dai = <&sai1>;
+			dai-tdm-slot-num = <2>;
+			dai-tdm-slot-width = <32>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&tfa9882>;
+			clocks = <&clks IMX6UL_CLK_SAI1>;
+			clock-names = "mclk";
+		};
+	};
+
+};
+
+&sai1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai1>;
+	assigned-clocks = <&clks IMX6UL_CLK_SAI1_SEL>,
+			<&clks IMX6UL_CLK_SAI1>;
+	assigned-clock-parents = <&clks IMX6UL_CLK_PLL4_AUDIO_DIV>;
+	assigned-clock-rates = <0>, <12288000>;
+	fsl,sai-mclk-direction-output;
+	status = "okay";
+};
+&sai2 {
+	status = "disabled";
+};
+
+&clks {
+	assigned-clocks = <&clks IMX6UL_CLK_PLL3_PFD2>,<&clks IMX6UL_CLK_PLL4_AUDIO_DIV>;
+	assigned-clock-rates = <320000000>,<786432000>;
+};
+
+&gpmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpmi_nand_1>;
+	status = "okay";
+	nand-on-flash-bbt;
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	uart-has-rtscts;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl_gpmi_nand_1: gpmi-nand-1 {
+		fsl,pins = <
+			MX6UL_PAD_NAND_CLE__RAWNAND_CLE         0xb0b1
+			MX6UL_PAD_NAND_ALE__RAWNAND_ALE         0xb0b1
+			MX6UL_PAD_NAND_WP_B__RAWNAND_WP_B       0xb0b1
+			MX6UL_PAD_NAND_READY_B__RAWNAND_READY_B 0xb000
+			MX6UL_PAD_NAND_CE0_B__RAWNAND_CE0_B     0xb0b1
+			MX6UL_PAD_NAND_CE1_B__RAWNAND_CE1_B     0xb0b1
+			MX6UL_PAD_NAND_RE_B__RAWNAND_RE_B       0xb0b1
+			MX6UL_PAD_NAND_WE_B__RAWNAND_WE_B       0xb0b1
+			MX6UL_PAD_NAND_DATA00__RAWNAND_DATA00   0xb0b1
+			MX6UL_PAD_NAND_DATA01__RAWNAND_DATA01   0xb0b1
+			MX6UL_PAD_NAND_DATA02__RAWNAND_DATA02   0xb0b1
+			MX6UL_PAD_NAND_DATA03__RAWNAND_DATA03   0xb0b1
+			MX6UL_PAD_NAND_DATA04__RAWNAND_DATA04   0xb0b1
+			MX6UL_PAD_NAND_DATA05__RAWNAND_DATA05   0xb0b1
+			MX6UL_PAD_NAND_DATA06__RAWNAND_DATA06   0xb0b1
+			MX6UL_PAD_NAND_DATA07__RAWNAND_DATA07   0xb0b1
+		>;
+ 	};
+	pinctrl_wifi: wifigrp {
+		fsl,pins = <
+			MX6UL_PAD_SNVS_TAMPER1__GPIO5_IO01 0x03029
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX6UL_PAD_UART2_TX_DATA__UART2_DCE_TX	0x1b0b1
+			MX6UL_PAD_UART2_RX_DATA__UART2_DCE_RX	0x1b0b1
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+    	fsl,pins = <
+			MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX 0x1b0b1
+			MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX 0x1b0b1
+			MX6UL_PAD_UART3_RTS_B__UART3_DCE_RTS  0x1b0b1
+			MX6UL_PAD_UART3_CTS_B__UART3_DCE_CTS  0x1b0b1
+		>;
+	};
+
+
+        pinctrl_pwm2: pwm2grp {
+                fsl,pins = <
+                        MX6UL_PAD_GPIO1_IO09__PWM2_OUT   0x110b0
+                >;
+        };
+
+        pinctrl_pwm3: pwm3grp {
+                fsl,pins = <
+                        MX6UL_PAD_GPIO1_IO04__PWM3_OUT   0x110b0
+                >;
+        };
+
+	pinctrl_usdhc1: usdhc1grp {
+		fsl,pins = <
+			MX6UL_PAD_SD1_CMD__USDHC1_CMD     	0x17059
+			MX6UL_PAD_SD1_CLK__USDHC1_CLK     	0x10059
+			MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 	0x17059
+			MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 	0x17059
+			MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 	0x17059
+			MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 	0x17059
+		>;
+	};
+
+   pinctrl_jnflash: jnflashgrp {
+		fsl,pins = <
+           MX6UL_PAD_ENET2_RX_DATA0__GPIO2_IO08       0x000010B0
+			MX6UL_PAD_ENET2_RX_DATA1__GPIO2_IO09       0x000010B0
+		>;
+	};
+
+	pinctrl_sai1: sai1grp {
+		fsl,pins = <
+			MX6UL_PAD_CSI_DATA04__SAI1_TX_SYNC 0x17088
+			MX6UL_PAD_CSI_DATA05__SAI1_TX_BCLK 0x17088
+			MX6UL_PAD_CSI_DATA07__SAI1_TX_DATA 0x11088
+		>;
+	};
+
+};
+
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+	mag3110@e {
+		compatible = "fsl,mag3110";
+		reg = <0x0e>;
+	};
+};
+
+
+&reg_sd1_vmmc {
+	regulator-always-on;
+};
+
+
+&usdhc1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	no-1-8-v;
+	non-removable;
+	pm-ignore-notify;
+	mmc-pwrseq = <&usdhc1_pwrseq>;
+	cap-power-off-card;
+	/delete-property/ wakeup-source;
+	/delete-property/ enable-sdio-wakeup;
+};
+
+&pwm1 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_pwm1>;
+        status = "okay";
+};
+
+&pwm2 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_pwm2>;
+        status = "okay";
+};
+
+&pwm3 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_pwm3>;
+        status = "okay";
+};
+
+&usdhc2 {
+	status = "disabled";
+};
+
+
+&fec1 {
+	status = "disabled";
+};
+
+&fec2 {
+	status = "disabled";
+};
diff -ruN a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
--- a/sound/soc/codecs/Kconfig	2020-09-26 19:03:16.000000000 +0300
+++ b/sound/soc/codecs/Kconfig	2020-10-03 20:53:08.608000000 +0300
@@ -185,6 +185,7 @@
 	select SND_SOC_TAS6424 if I2C
 	select SND_SOC_TDA7419 if I2C
 	select SND_SOC_TFA9879 if I2C
+	select SND_SOC_TFA9882
 	select SND_SOC_TLV320AIC23_I2C if I2C
 	select SND_SOC_TLV320AIC23_SPI if SPI_MASTER
 	select SND_SOC_TLV320AIC26 if SPI_MASTER
@@ -1138,6 +1139,10 @@
 	tristate "NXP Semiconductors TFA9879 amplifier"
 	depends on I2C

+config SND_SOC_TFA9882
+	tristate "NXP Semiconductors TFA9882 DAC with amplifier"
+	depends on I2C
+
 config SND_SOC_TLV320AIC23
 	tristate

diff -ruN a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
--- a/sound/soc/codecs/Makefile	2020-09-26 19:03:16.000000000 +0300
+++ b/sound/soc/codecs/Makefile	2020-10-03 20:51:56.291000000 +0300
@@ -197,6 +197,7 @@
 snd-soc-tas6424-objs := tas6424.o
 snd-soc-tda7419-objs := tda7419.o
 snd-soc-tfa9879-objs := tfa9879.o
+snd-soc-tfa9882-objs := tfa9882.o
 snd-soc-tlv320aic23-objs := tlv320aic23.o
 snd-soc-tlv320aic23-i2c-objs := tlv320aic23-i2c.o
 snd-soc-tlv320aic23-spi-objs := tlv320aic23-spi.o
@@ -480,6 +481,7 @@
 obj-$(CONFIG_SND_SOC_TAS6424)	+= snd-soc-tas6424.o
 obj-$(CONFIG_SND_SOC_TDA7419)	+= snd-soc-tda7419.o
 obj-$(CONFIG_SND_SOC_TFA9879)	+= snd-soc-tfa9879.o
+obj-$(CONFIG_SND_SOC_TFA9882)	+= snd-soc-tfa9882.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23)	+= snd-soc-tlv320aic23.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23_I2C)	+= snd-soc-tlv320aic23-i2c.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23_SPI)	+= snd-soc-tlv320aic23-spi.o
diff -ruN a/sound/soc/codecs/tfa9882.c b/sound/soc/codecs/tfa9882.c
--- a/sound/soc/codecs/tfa9882.c	1970-01-01 03:00:00.000000000 +0300
+++ b/sound/soc/codecs/tfa9882.c	2020-10-02 19:49:37.000000000 +0300
@@ -0,0 +1,234 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * tfa9882.c  --  TFA9882 ALSA SoC Audio driver
+ *
+ * Copyright 2009 Wolfson Microelectronics plc
+ * Copyright 2017 NXP
+ *
+ * Based on WM8524 ALSA SoC Audio driver written by Mihai Serban
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+
+#define TFA9882_NUM_RATES 7
+
+/* codec private data */
+struct tfa9882_priv {
+	struct gpio_desc *mute;
+	unsigned int sysclk;
+	unsigned int rate_constraint_list[TFA9882_NUM_RATES];
+	struct snd_pcm_hw_constraint_list rate_constraint;
+};
+
+
+static const struct snd_soc_dapm_widget tfa9882_dapm_widgets[] = {
+SND_SOC_DAPM_DAC("DAC", "Playback", SND_SOC_NOPM, 0, 0),
+SND_SOC_DAPM_OUTPUT("LINEVOUTL"),
+SND_SOC_DAPM_OUTPUT("LINEVOUTR"),
+};
+
+static const struct snd_soc_dapm_route tfa9882_dapm_routes[] = {
+	{ "LINEVOUTL", NULL, "DAC" },
+	{ "LINEVOUTR", NULL, "DAC" },
+};
+
+static const struct {
+	int value;
+	int ratio;
+} lrclk_ratios[TFA9882_NUM_RATES] = {
+	{ 1, 128 },
+	{ 2, 192 },
+	{ 3, 256 },
+	{ 4, 384 },
+	{ 5, 512 },
+	{ 6, 768 },
+	{ 7, 1152 },
+};
+
+static int tfa9882_startup(struct snd_pcm_substream *substream,
+			  struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct tfa9882_priv *tfa9882 = snd_soc_component_get_drvdata(component);
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	/* The set of sample rates that can be supported depends on the
+	 * MCLK supplied to the CODEC - enforce this.
+	 */
+	if (!tfa9882->sysclk) {
+		dev_err(component->dev,
+			"No MCLK configured, call set_sysclk() on init\n");
+		return -EINVAL;
+	}
+
+	if (!rtd->dai_link->be_hw_params_fixup)
+		snd_pcm_hw_constraint_list(substream->runtime, 0,
+					   SNDRV_PCM_HW_PARAM_RATE,
+					   &tfa9882->rate_constraint);
+
+	return 0;
+}
+
+static void tfa9882_shutdown(struct snd_pcm_substream *substream,
+			  struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct tfa9882_priv *tfa9882 = snd_soc_component_get_drvdata(component);
+
+}
+
+static int tfa9882_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_component *component = codec_dai->component;
+	struct tfa9882_priv *tfa9882 = snd_soc_component_get_drvdata(component);
+	unsigned int val;
+	int i, j = 0;
+
+	tfa9882->sysclk = freq;
+
+	tfa9882->rate_constraint.count = 0;
+	for (i = 0; i < ARRAY_SIZE(lrclk_ratios); i++) {
+		val = freq / lrclk_ratios[i].ratio;
+		/* Check that it's a standard rate since core can't
+		 * cope with others and having the odd rates confuses
+		 * constraint matching.
+		 */
+		switch (val) {
+		case 8000:
+		case 32000:
+		case 44100:
+		case 48000:
+		case 88200:
+		case 96000:
+		case 176400:
+		case 192000:
+			dev_dbg(component->dev, "Supported sample rate: %dHz\n",
+				val);
+			tfa9882->rate_constraint_list[j++] = val;
+			tfa9882->rate_constraint.count++;
+			break;
+		default:
+			dev_dbg(component->dev, "Skipping sample rate: %dHz\n",
+				val);
+		}
+	}
+
+	/* Need at least one supported rate... */
+	if (tfa9882->rate_constraint.count == 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int tfa9882_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	fmt &= (SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_INV_MASK |
+		SND_SOC_DAIFMT_MASTER_MASK);
+
+	if (fmt != (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		    SND_SOC_DAIFMT_CBS_CFS)) {
+		dev_err(codec_dai->dev, "Invalid DAI format\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#define TFA9882_RATES SNDRV_PCM_RATE_8000_192000
+
+#define TFA9882_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\
+			SNDRV_PCM_FMTBIT_S32_LE)
+
+static const struct snd_soc_dai_ops tfa9882_dai_ops = {
+	.startup	= tfa9882_startup,
+	.shutdown	= tfa9882_shutdown,
+	.set_sysclk	= tfa9882_set_dai_sysclk,
+	.set_fmt	= tfa9882_set_fmt,
+};
+
+static struct snd_soc_dai_driver tfa9882_dai = {
+	.name = "tfa9882-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = TFA9882_RATES,
+		.formats = TFA9882_FORMATS,
+	},
+	.ops = &tfa9882_dai_ops,
+};
+
+static int tfa9882_probe(struct snd_soc_component *component)
+{
+	struct tfa9882_priv *tfa9882 = snd_soc_component_get_drvdata(component);
+
+	tfa9882->rate_constraint.list = &tfa9882->rate_constraint_list[0];
+	tfa9882->rate_constraint.count =
+		ARRAY_SIZE(tfa9882->rate_constraint_list);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver soc_component_dev_tfa9882 = {
+	.probe			= tfa9882_probe,
+	.dapm_widgets		= tfa9882_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(tfa9882_dapm_widgets),
+	.dapm_routes		= tfa9882_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(tfa9882_dapm_routes),
+	.idle_bias_on		= 1,
+	.use_pmdown_time	= 1,
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
+};
+
+static const struct of_device_id tfa9882_of_match[] = {
+	{ .compatible = "fsl,tfa9882" },
+	{ /* sentinel*/ }
+};
+MODULE_DEVICE_TABLE(of, tfa9882_of_match);
+
+static int tfa9882_codec_probe(struct platform_device *pdev)
+{
+	struct tfa9882_priv *tfa9882;
+	int ret;
+
+	tfa9882 = devm_kzalloc(&pdev->dev, sizeof(struct tfa9882_priv),
+						  GFP_KERNEL);
+	if (tfa9882 == NULL)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, tfa9882);
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+			&soc_component_dev_tfa9882, &tfa9882_dai, 1);
+	if (ret < 0)
+		dev_err(&pdev->dev, "Failed to register component: %d\n", ret);
+
+	return ret;
+}
+
+static struct platform_driver tfa9882_codec_driver = {
+	.probe		= tfa9882_codec_probe,
+	.driver		= {
+		.name	= "tfa9882-codec",
+		.of_match_table = tfa9882_of_match,
+	},
+};
+module_platform_driver(tfa9882_codec_driver);
+
+MODULE_DESCRIPTION("ASoC tfa9882 driver");
+MODULE_AUTHOR("-=Alx=- <alx.v.sadkov@gmail.com>");
+MODULE_ALIAS("platform:tfa9882-codec");
+MODULE_LICENSE("GPL");
diff -ruN a/sound/soc/codecs/tfa9882.h b/sound/soc/codecs/tfa9882.h
--- a/sound/soc/codecs/tfa9882.h	1970-01-01 03:00:00.000000000 +0300
+++ b/sound/soc/codecs/tfa9882.h	2020-10-02 06:26:57.000000000 +0300
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * tfa9879.h  --  driver for NXP Semiconductors TFA9879
+ *
+ * Copyright (C) 2014 Axentia Technologies AB
+ * Author: Peter Rosin <peda@axentia.se>
+ */
+
+#ifndef _TFA9882_H
+#define _TFA9882_H
+
+
+#endif
diff -ruN a/sound/soc/fsl/imx-tfa9882.c b/sound/soc/fsl/imx-tfa9882.c
--- a/sound/soc/fsl/imx-tfa9882.c	1970-01-01 03:00:00.000000000 +0300
+++ b/sound/soc/fsl/imx-tfa9882.c	2020-10-02 19:35:45.000000000 +0300
@@ -0,0 +1,315 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <sound/control.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/mfd/syscon.h>
+
+struct imx_priv {
+	struct snd_soc_dai_link dai[3];
+	struct platform_device *pdev;
+	struct platform_device *asrc_pdev;
+	struct snd_soc_card card;
+	struct clk *codec_clk;
+	unsigned int clk_frequency;
+	u32 asrc_rate;
+	u32 asrc_format;
+};
+
+static const struct snd_soc_dapm_widget imx_tfa9882_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("Line Out Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+};
+
+static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_card *card = rtd->card;
+	struct device *dev = card->dev;
+	unsigned int fmt;
+	int ret = 0;
+
+	fmt = SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+	if (ret) {
+		dev_err(dev, "failed to set cpu dai fmt: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_tdm_slot(cpu_dai, 0, 0, 2,
+					params_physical_width(params));
+	if (ret) {
+		dev_err(dev, "failed to set cpu dai tdm slot: %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static struct snd_soc_ops imx_hifi_ops = {
+	.hw_params = imx_hifi_hw_params,
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	{"Playback",  NULL, "CPU-Playback"},
+	{"CPU-Playback",  NULL, "ASRC-Playback"},
+};
+
+static int be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
+			      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_card *card = rtd->card;
+	struct imx_priv *priv = snd_soc_card_get_drvdata(card);
+	struct snd_interval *rate;
+	struct snd_mask *mask;
+
+	if (!priv->asrc_pdev)
+		return -EINVAL;
+
+	rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	rate->max = priv->asrc_rate;
+	rate->min = priv->asrc_rate;
+
+	mask = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
+	snd_mask_none(mask);
+	snd_mask_set(mask, priv->asrc_format);
+
+	return 0;
+}
+
+static int imx_tfa9882_late_probe(struct snd_soc_card *card)
+{
+	struct snd_soc_pcm_runtime *rtd = list_first_entry(
+		&card->rtd_list, struct snd_soc_pcm_runtime, list);
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct imx_priv *priv = snd_soc_card_get_drvdata(card);
+	int ret;
+
+	priv->clk_frequency = clk_get_rate(priv->codec_clk);
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, priv->clk_frequency,
+							SND_SOC_CLOCK_IN);
+
+	return 0;
+}
+
+static int imx_tfa9882_probe(struct platform_device *pdev)
+{
+	struct device_node *cpu_np, *codec_np = NULL;
+	struct device_node *asrc_np = NULL;
+	struct platform_device *asrc_pdev = NULL;
+	struct platform_device *cpu_pdev;
+	struct imx_priv *priv;
+	struct platform_device *codec_pdev = NULL;
+	struct snd_soc_dai_link_component *dlc;
+	int ret;
+	u32 width;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->pdev = pdev;
+
+	dlc = devm_kzalloc(&pdev->dev, 9 * sizeof(*dlc), GFP_KERNEL);
+	if (!dlc)
+		return -ENOMEM;
+
+	cpu_np = of_parse_phandle(pdev->dev.of_node, "audio-cpu", 0);
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "cpu dai phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	codec_np = of_parse_phandle(pdev->dev.of_node, "audio-codec", 0);
+	if (!codec_np) {
+		dev_err(&pdev->dev, "phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	asrc_np = of_parse_phandle(pdev->dev.of_node, "asrc-controller", 0);
+	if (asrc_np) {
+		asrc_pdev = of_find_device_by_node(asrc_np);
+		priv->asrc_pdev = asrc_pdev;
+	}
+
+	cpu_pdev = of_find_device_by_node(cpu_np);
+	if (!cpu_pdev) {
+		dev_err(&pdev->dev, "failed to find SAI platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	codec_pdev = of_find_device_by_node(codec_np);
+	if (!codec_pdev || !codec_pdev->dev.driver) {
+		dev_dbg(&pdev->dev, "failed to find codec platform device\n");
+		ret = -EPROBE_DEFER;
+		goto fail;
+	}
+
+	priv->codec_clk = devm_clk_get(&codec_pdev->dev, "mclk");
+	if (IS_ERR(priv->codec_clk)) {
+		ret = PTR_ERR(priv->codec_clk);
+		dev_err(&pdev->dev, "failed to get codec clk: %d\n", ret);
+		goto fail;
+	}
+
+	priv->dai[0].cpus = &dlc[0];
+	priv->dai[0].num_cpus = 1;
+	priv->dai[0].platforms = &dlc[1];
+	priv->dai[0].num_platforms = 1;
+	priv->dai[0].codecs = &dlc[2];
+	priv->dai[0].num_codecs = 1;
+
+	priv->dai[0].name               = "HiFi";
+	priv->dai[0].stream_name        = "HiFi";
+	priv->dai[0].codecs->dai_name     = "tfa9882-hifi",
+	priv->dai[0].ops                = &imx_hifi_ops,
+	priv->dai[0].codecs->of_node      = codec_np;
+	priv->dai[0].cpus->dai_name = dev_name(&cpu_pdev->dev);
+	priv->dai[0].platforms->of_node = cpu_np;
+	priv->dai[0].playback_only	= 1;
+
+	priv->card.late_probe = imx_tfa9882_late_probe;
+	priv->card.num_links = 1;
+	priv->card.dev = &pdev->dev;
+	priv->card.owner = THIS_MODULE;
+	priv->card.dapm_widgets = imx_tfa9882_dapm_widgets;
+	priv->card.num_dapm_widgets = ARRAY_SIZE(imx_tfa9882_dapm_widgets);
+	priv->card.dai_link = priv->dai;
+	priv->card.dapm_routes = audio_map;
+	priv->card.num_dapm_routes = 1;
+
+	/*if there is no asrc controller, we only enable one device*/
+	if (asrc_pdev) {
+		priv->dai[1].cpus = &dlc[3];
+		priv->dai[1].num_cpus = 1;
+		priv->dai[1].platforms = &dlc[4];
+		priv->dai[1].num_platforms = 1;
+		priv->dai[1].codecs = &dlc[5];
+		priv->dai[1].num_codecs = 1;
+
+		priv->dai[2].cpus = &dlc[6];
+		priv->dai[2].num_cpus = 1;
+		priv->dai[2].platforms = &dlc[7];
+		priv->dai[2].num_platforms = 1;
+		priv->dai[2].codecs = &dlc[8];
+		priv->dai[2].num_codecs = 1;
+
+		priv->dai[1].name = "HiFi-ASRC-FE";
+		priv->dai[1].stream_name = "HiFi-ASRC-FE";
+		priv->dai[1].codecs->dai_name = "snd-soc-dummy-dai";
+		priv->dai[1].codecs->name = "snd-soc-dummy";
+		priv->dai[1].cpus->of_node    = asrc_np;
+		priv->dai[1].platforms->of_node   = asrc_np;
+		priv->dai[1].dynamic   = 1;
+		priv->dai[1].dpcm_playback  = 1;
+		priv->dai[1].dpcm_capture   = 0;
+
+		priv->dai[2].name = "HiFi-ASRC-BE";
+		priv->dai[2].stream_name = "HiFi-ASRC-BE";
+		priv->dai[2].codecs->dai_name  = "tfa9882-hifi";
+		priv->dai[2].codecs->of_node   = codec_np;
+		priv->dai[2].cpus->of_node     = cpu_np;
+		priv->dai[2].platforms->name   = "snd-soc-dummy";
+		priv->dai[2].no_pcm          = 1;
+		priv->dai[2].dpcm_playback  = 1;
+		priv->dai[2].dpcm_capture   = 0;
+		priv->dai[2].ops = &imx_hifi_ops,
+		priv->dai[2].be_hw_params_fixup = be_hw_params_fixup,
+		priv->card.num_links = 3;
+		priv->card.dai_link = &priv->dai[0];
+		priv->card.num_dapm_routes += 1;
+
+		ret = of_property_read_u32(asrc_np, "fsl,asrc-rate",
+					   &priv->asrc_rate);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to get output rate\n");
+			ret = -EINVAL;
+			goto fail;
+		}
+
+		ret = of_property_read_u32(asrc_np, "fsl,asrc-width", &width);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to get output rate\n");
+			ret = -EINVAL;
+			goto fail;
+		}
+
+		if (width == 24)
+			priv->asrc_format = SNDRV_PCM_FORMAT_S24_LE;
+		else
+			priv->asrc_format = SNDRV_PCM_FORMAT_S16_LE;
+	}
+
+	ret = snd_soc_of_parse_card_name(&priv->card, "model");
+	if (ret)
+		goto fail;
+
+	ret = snd_soc_of_parse_audio_routing(&priv->card, "audio-routing");
+	if (ret)
+		goto fail;
+
+	snd_soc_card_set_drvdata(&priv->card, priv);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, &priv->card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+		goto fail;
+	}
+
+	ret = 0;
+fail:
+	if (cpu_np)
+		of_node_put(cpu_np);
+	if (codec_np)
+		of_node_put(codec_np);
+
+	return ret;
+}
+
+static const struct of_device_id imx_tfa9882_dt_ids[] = {
+	{ .compatible = "fsl,imx-audio-tfa9882", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_tfa9882_dt_ids);
+
+static struct platform_driver imx_tfa9882_driver = {
+	.driver = {
+		.name = "imx-tfa9882",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = imx_tfa9882_dt_ids,
+	},
+	.probe = imx_tfa9882_probe,
+};
+module_platform_driver(imx_tfa9882_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Freescale i.MX TFA9882 ASoC machine driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:imx-tfa9882");
diff -ruN a/sound/soc/fsl/Kconfig b/sound/soc/fsl/Kconfig
--- a/sound/soc/fsl/Kconfig	2020-09-26 19:03:16.000000000 +0300
+++ b/sound/soc/fsl/Kconfig	2020-10-03 21:18:57.639000000 +0300
@@ -289,6 +289,17 @@
 	select SND_SOC_MC13783
 	select SND_SOC_IMX_PCM_DMA

+config SND_SOC_IMX_TFA9882
+	tristate "SoC Audio support for i.MX boards with tfa9882"
+	select SND_SOC_TFA9882
+	select SND_SOC_IMX_PCM_DMA
+	select SND_SOC_FSL_SAI
+	select SND_SOC_FSL_UTILS
+	help
+	  SoC Audio support for i.MX boards with TFA9882
+	  Say Y if you want to add support for SoC audio on an i.MX board with
+	  a tfa9882 codec.
+
 config SND_SOC_FSL_ASOC_CARD
 	tristate "Generic ASoC Sound Card with ASRC support"
 	depends on OF && I2C
diff -ruN a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
--- a/sound/soc/fsl/Makefile	2020-09-26 19:03:16.000000000 +0300
+++ b/sound/soc/fsl/Makefile	2020-10-03 22:00:10.087000000 +0300
@@ -63,6 +63,7 @@
 snd-soc-imx-spdif-objs := imx-spdif.o
 snd-soc-imx-mc13783-objs := imx-mc13783.o
 snd-soc-imx-audmix-objs := imx-audmix.o
+snd-soc-imx-tfa9882-objs := imx-tfa9882.o

 obj-$(CONFIG_SND_SOC_EUKREA_TLV320) += snd-soc-eukrea-tlv320.o
 obj-$(CONFIG_SND_SOC_PHYCORE_AC97) += snd-soc-phycore-ac97.o
@@ -73,3 +74,4 @@
 obj-$(CONFIG_SND_SOC_IMX_SPDIF) += snd-soc-imx-spdif.o
 obj-$(CONFIG_SND_SOC_IMX_MC13783) += snd-soc-imx-mc13783.o
 obj-$(CONFIG_SND_SOC_IMX_AUDMIX) += snd-soc-imx-audmix.o
+obj-$(CONFIG_SND_SOC_IMX_TFA9882) += snd-soc-imx-tfa9882.o
